<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>(题解)[AtCoder Beginner Contest 408] D - Flip to Gather</title>
      <link href="/2025/06/01/%5B%E9%A2%98%E8%A7%A3%5DAT_abc408_d%20%5BABC408D%5D%20Flip%20to%20Gather/"/>
      <url>/2025/06/01/%5B%E9%A2%98%E8%A7%A3%5DAT_abc408_d%20%5BABC408D%5D%20Flip%20to%20Gather/</url>
      
        <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给定一个字符串，每次可以将 $0$ 改为 $1$，将 $1$ 改为 $0$。现想让这个字符串上所有的 $1$ 连在一起，求最小操作次数。</p><h1 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h1><p>最小操作次数，考虑 DP。</p><p>设 $dp[i][j][k]$ 表示：<strong>将原字符串</strong>的前 $i$ 位改为以 $j$（$j$ 为 $0$ 或 $1$）结尾，且有连续的 $1$ 存在（$k$ 为 $1$ 表示存在）的字符串的最小操作次数。</p><p>然后推导状态转移方程。</p><p>首先 $dp[i][1][0]$ 是不满足状态定义的，无需讨论。因为它既然以 $1$ 结尾，那么一定会有连续的 $1$ 存在。</p><p>然后看 $dp[i][0][0]$，根据定义，可以得出变化后的字符串长这个样子：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/9fudwvt6.png?x-oss-process=image/resize,m_lfit,h_170,w_225" alt="dpi00png"></p><p>看图可以轻松得出：$dp[i][0][0]&#x3D;dp[i-1][0][0]+[s_i为1]$。</p><p>然后看 $dp[i][0][1]$ 的图：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/g1mp3cpi.png?x-oss-process=image/resize,m_lfit,h_170,w_225" alt="dpi01png"></p><p>同样：$dp[i][0][1]&#x3D;min(dp[i-1][0][1],dp[i-1][1][1])+[s_i为1]$。</p><p>最后看 $dp[i][1][1]$ 的图：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/15b4lo1j.png?x-oss-process=image/resize,m_lfit,h_170,w_225" alt="dpi11png"></p><p>同样：$dp[i][1][1]&#x3D;min(dp[i-1][0][0],dp[i-1][1][1])+[s_i为0]$。</p><p>值得注意的是 $dp[i][1][1]$ 无法被 $dp[i][0][1]$ 转移，因为这样的 $1$ 不是连续的。</p><h1 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=2e5+10;</span><br><span class="line">int t,n;</span><br><span class="line">int dp[maxn][2][2];</span><br><span class="line">string s;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line">while(t--)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;s;</span><br><span class="line">memset(dp,0,sizeof(dp));</span><br><span class="line">dp[0][0][0]=s[0]==&#x27;1&#x27;;</span><br><span class="line">dp[0][1][1]=s[0]==&#x27;0&#x27;;</span><br><span class="line">for(int i=1;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">int s1=s[i]==&#x27;1&#x27;,s0=s[i]==&#x27;0&#x27;;</span><br><span class="line">dp[i][0][0]=dp[i-1][0][0]+s1;</span><br><span class="line">dp[i][0][1]=min(dp[i-1][0][1],dp[i-1][1][1])+s1;</span><br><span class="line">dp[i][1][1]=min(dp[i-1][0][0],dp[i-1][1][1])+s0;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;min(dp[n-1][0][0],min(dp[n-1][0][1],dp[n-1][1][1]))&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(题解)[AtCoder Beginner Contest 407] C - Security 2</title>
      <link href="/2025/05/27/AT_abc407_c%20%5BABC407C%5D%20Security%202%20%E9%A2%98%E8%A7%A3/"/>
      <url>/2025/05/27/AT_abc407_c%20%5BABC407C%5D%20Security%202%20%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>在一个空串末尾添加 $ 0 $ 或将空串上的数字全部加上 $1$ ，满 $10$ 退回 $0$ ，求将空串变为目标串 $S$ 所需最小操作次数。</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>考虑贪心。</p><p>我们先把<strong>空串</strong>变为都是 $0$ 的<strong>操作</strong>串，并且遍历<strong>目标串</strong>。</p><p>由此可得，题目的添加操作就相当于</p><blockquote><p>将 $[1,i]$ 中每一个数加 $1$ </p></blockquote><p>由此不难发现，当目标串呈<strong>单调递减</strong>时，所需的最小操作步数为<strong>目标串中最大的数</strong>。如当前目标串为 $94221$ ，所需最小操作次数就为   $9+5&#x3D;14$ 。（别忘了加 $0$ 也要加次数）</p><p>这样我们就可以把目标串分为<strong>很多个单调递减的序列</strong>。</p><p>但要是 $S_i$ <strong>不属于</strong>上一个单调递减的序列呢？比如当前目标串是 $527$ 。我们遍历到了第三位，想让最低位为 $7$ ，不可避免的就要将 $[1,3]$ 区间内所有数加上 $7$ ，可我们 $[1,2]$ 区间内的数已经处理好了，我们不想改变它，怎么办呢？</p><p>根据题目满 $10$ 归 $0$ 的性质，可以得出</p><blockquote><p>任何一个数加上了10，都可以回到原来那个数。</p></blockquote><p>那这样就好办了，又要将 $[1,3]$ 加上 $7$ ，又要 $[1,2]$ 不变，那么先 $[1,2]$ 加上 $3$ ，再让 $[1,3]$ 加上 $7$ 就好了嘛。这样 $[1,2]$ 总共加了 $10$ 保持不变，且总共操作了 $10$ 次，将操作次数加上 $10$ 就好啦。</p><p>也就是说，当 $S_i\leq S_{i-1}$ 时，满足单调递减，就不用增加操作次数；当 $S_i&gt;S_{i-1} $ 时，是新递减序列的开头，需要加上 $10$ 使得操作串与目标串统一。</p><h1 id="简洁的代码"><a href="#简洁的代码" class="headerlink" title="简洁的代码"></a>简洁的代码</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int ans,l=INT_MAX,n;</span><br><span class="line">string s;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"> cin&gt;&gt;s;</span><br><span class="line"> n=s.size();</span><br><span class="line"> ans+=n;</span><br><span class="line"> ans+=s[0]-&#x27;0&#x27;;</span><br><span class="line"> for(int i=0;i&lt;n;i++)</span><br><span class="line"> &#123;</span><br><span class="line"> int t=s[i]-&#x27;0&#x27;;</span><br><span class="line"> if(t&gt;l) ans+=10;</span><br><span class="line"> l=t;</span><br><span class="line"> &#125;</span><br><span class="line"> cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(题解)[P9245 蓝桥杯 2023 省B] 景区导游</title>
      <link href="/2025/04/26/P9245%20%5B%E8%93%9D%E6%A1%A5%E6%9D%AF%202023%20%E7%9C%81%20B%5D%20%E6%99%AF%E5%8C%BA%E5%AF%BC%E6%B8%B8%20%E9%A2%98%E8%A7%A3/"/>
      <url>/2025/04/26/P9245%20%5B%E8%93%9D%E6%A1%A5%E6%9D%AF%202023%20%E7%9C%81%20B%5D%20%E6%99%AF%E5%8C%BA%E5%AF%BC%E6%B8%B8%20%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>本文分为两个部分，一是介绍倍增法求LCA（最近公共祖先），二是回归题目的题解。</p><h1 id="倍增法求LCA"><a href="#倍增法求LCA" class="headerlink" title="倍增法求LCA"></a>倍增法求LCA</h1><h2 id="实现过程及原理"><a href="#实现过程及原理" class="headerlink" title="实现过程及原理"></a>实现过程及原理</h2><p>（为方便读者理解，本小节暂不探讨如何实现代码，只谈算法思路。具体实现细节见下小节。）</p><p>在一个树上有两个结点 $u$ 和 $v$ ，$dep_i$ 表示从根结点到 $i$ 的距离， $dep_u&gt;dep_v$ ，求 $lca(u,v)$。</p><p>大致思路是先将 $u$ 和 $v$ <strong>移至同一层</strong>，再<strong>同时</strong>将两个结点向<strong>上移</strong>，直到相同为止。（上移一层指将 u 更新为他的父结点 。）</p><h3 id="将-u-和-v-提至同一层"><a href="#将-u-和-v-提至同一层" class="headerlink" title="将 $u$ 和 $v$ 提至同一层"></a>将 $u$ 和 $v$ 提至同一层</h3><p>首先需要将 $u$ 和 $v$ 移动到同一层上，也就是将 $u$ 上移 $dep_u-dep_v$ 层。</p><p>设 $k &#x3D; dep_u-dep_v$ ，则很容易想出将 $u$ 上移 $k$ 次，但这样<strong>效率很低</strong>。如果用 $fa_{u,k}$ 来记录 $u$ 点上移 $k$ 次后的节点，则需要<strong>很多空间</strong>。</p><p>我们采取一个<strong>折中方案</strong>，用 $fa_{i,j}$ 来记录 $i$ 节点上移 $2^i$ 后的结点——恭喜你发现了<strong>倍增法</strong>。</p><p>通过这样一个 $fa_{i,j}$ 数组，我们可以推理出<strong>每一个 $u$ 节点上移 $k$ 层</strong> 后的结点，方法如下：从低位向高位依次遍历 $k$ 的<strong>二进制</strong>，若第 $i$ 位为 $1$ ，则将 $u$ 上移 $2^i$ 层，若为 $0$ 则不做处理。如此遍历完成后， $u$ 点总共便上移了 $k$ 层。如果此时$u&#x3D;v$ ，那么 $lca(u,v)$ 就是 $v$ 啦。</p><h3 id="同时上移-u-和-v-，直到到达-lca-u-v"><a href="#同时上移-u-和-v-，直到到达-lca-u-v" class="headerlink" title="同时上移 $u$ 和 $v$ ，直到到达 $lca(u,v)$"></a>同时上移 $u$ 和 $v$ ，直到到达 $lca(u,v)$</h3><p>此时的 $u$ 和 $v$ 已经处在同一层，所以 $dep_u$ 等价于 $dep_v$ 。</p><p>注意到，$fa_{u,i}和fa_{v,i}$ 之间（$fa$ 数组里存的是结点编号），只有两种情况：<strong>相同</strong>或<strong>不相同</strong>。如果相同，则说明 $u+2^i &#x3D; v+2^i$ ，此时结点是它们的<strong>公共祖先</strong>，但<strong>不一定</strong>是最近公共祖先；如果不同，则说明 $fa_{u,i}$ 和 $fa_{v,i}$ 这两个结点的 $dep$ <strong>都小于</strong>他们的<strong>最近公共祖先</strong>。</p><p>我们发现，如果在 $fa_{u,i}&#x3D;fa_{v,i}$的情况下，将 $u和v$ 结点上移 $2^i$ 层很可能就会<strong>移过头</strong>。但若 $fa_{u,i}\neq fa_{v,i}$ ，将 $u和v$上移 $2^i$ 层，就会<strong>无限逼近</strong>它们的最近公共祖先。</p><p>现在我们依次遍历每一个 $i$ ，从小到大或从大到小都可以，我们从大到小。当 $u+fa_{u,i}\neq v+fa_{v,i}$ 时，我们将 $u$ 和 $v$上移 $2^i$ 层。那么循环结束后，$u和v$ 究竟上移到了哪里呢？</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/zyam7d1n.png"></p><p>设距离 $k&#x3D;dep_{lca(u,v)}-1-dep_u$。如果 $fa_{u,i}&#x3D;fa_{v,i}$ ，则 $2^i&gt;k$，此时 $k$ 的第 $i$ 位二进制<strong>一定</strong>是 $0$ 。若 $fa_{u,i}\neq fa_{v,i}$ ，则 $2^i\le k$ ，此时 $k$ 的 $i$ 位二进制<strong>一定</strong>是 $1$ 。我们发现，如果在所有 $fa_{u,i}\neq fa_{v,i}$ 时将 $u$ 加上 $2^i$ ，则最后就是<strong>加了 $k$ 的每一位二进制</strong>，也就是总共加了 $k$ 。</p><p>现在我们知道了，这样做到最后一共是上移了 $dep_{lca(u,v)}-1-dep_u$ 层，$dep_u+dep_{lca(u,v)}-1-dep_u&#x3D;dep_{lca(u,v)}-1$，因此我们<strong>最后到达的地方是 $lca(u,v)$ 下面的一个结点</strong>，所以最后我们要返回这个结点的父节点。</p><h2 id="细节问题探讨"><a href="#细节问题探讨" class="headerlink" title="细节问题探讨"></a>细节问题探讨</h2><h3 id="fa-数组的计算"><a href="#fa-数组的计算" class="headerlink" title="$fa$ 数组的计算"></a>$fa$ 数组的计算</h3><p>采用动态规划的思想，可以先确定边界。$fa_{i,0}$ 是 $i$ 的父节点，这个可以深搜或广搜算。</p><p>然后状态转移方程是 $fa_{i,j}&#x3D;fa_{fa_{i,j-1},j-1}$ ，说人话就是 $i+2^j&#x3D;i+2^{j-1}+2^{j-1}$ 。</p><p>画一张图来推导循环先后。下图是一个$fa$ 数组。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/lfcqxfl1.png"></p><p>$fa_{i+2^{j-1},j-1}$ 的位置是只能确定列的，因此我们要一列一列的求，也就是先遍历 $j$ 。</p><h3 id="dep-数组的计算"><a href="#dep-数组的计算" class="headerlink" title="$dep$ 数组的计算"></a>$dep$ 数组的计算</h3><p>深搜或广搜都行，再次不多赘述。</p><h1 id="回归题目"><a href="#回归题目" class="headerlink" title="回归题目"></a>回归题目</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>在一个有 $N$ 个点的有权图中，计算经过$A_1,A_2…A_{i-1},A_{i+1}…A_k$ 这几个点所要的最少时间。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>因为是树上求最短路径，所以想到 $lca$ 。用一个 $S$ 记录经过 $A_1,A_2,…A_k$ 的最短时间，用 $dis_{u,v}$ 表示从 $u$ 到 $v$ 最短时间。之后跳过某个点的时候，在 $S$ 上删掉一些 $dis$，加上一些 $dis$ 就可以了。以样例 $2,6,5,1$ 为例，具体如图。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/6ltyyw63.png"></p><p>跳过起点 （跳过2）：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/rvsq6udd.png"></p><p>剩下的 “O” 就是 $dis_{6,5} + dis_{5,1}$ 时留下的标记了。</p><p>跳过中间点（跳过6）：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/ofoph7d5.png"></p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/9rbynebq.png"></p><p>剩下的 “O” 就是 $dis_{2,5} + dis_{5,1}$ 时留下的标记了。</p><p>跳过终点（跳过1）：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/osfu88vd.png"></p><p>剩下的 “O” 就是 $dis_{2,6} + dis_{6,5}$ 时留下的标记了。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define int long long</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=1e5+10;</span><br><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">int v,w;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;node&gt; G[maxn];</span><br><span class="line">int dep[maxn],fa[maxn][20];</span><br><span class="line">int a[maxn],sum[maxn];// sum[i] 为 1~i的时间 </span><br><span class="line">int n,k,s;</span><br><span class="line"></span><br><span class="line">//标准lca模板 </span><br><span class="line">void dfs(int u,int from)</span><br><span class="line">&#123;</span><br><span class="line">for(node t:G[u])</span><br><span class="line">&#123;</span><br><span class="line">int v=t.v;</span><br><span class="line">if(v==from) continue ;</span><br><span class="line">dep[v]=dep[u]+1;</span><br><span class="line">fa[v][0]=u;</span><br><span class="line">sum[v]=sum[u]+t.w;</span><br><span class="line">dfs(v,u);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void father()</span><br><span class="line">&#123;</span><br><span class="line">for(int j=1;j&lt;20;j++)</span><br><span class="line">&#123;</span><br><span class="line">for(int i=1;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">fa[i][j]=fa[fa[i][j-1]][j-1];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int lca(int u,int v)</span><br><span class="line">&#123;</span><br><span class="line">if(dep[u]&lt;dep[v]) swap(u,v);</span><br><span class="line">int k=dep[u]-dep[v];</span><br><span class="line">for(int i=0;i&lt;20;i++)</span><br><span class="line">&#123;</span><br><span class="line">if(k&amp;(1&lt;&lt;i)) u=fa[u][i];</span><br><span class="line">&#125;</span><br><span class="line">if(u==v) return u;</span><br><span class="line">for(int i=19;i&gt;=0;i--)</span><br><span class="line">&#123;</span><br><span class="line">if(fa[u][i]!=fa[v][i])</span><br><span class="line">&#123;</span><br><span class="line">u=fa[u][i];</span><br><span class="line">v=fa[v][i];</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">return fa[u][0];</span><br><span class="line">&#125;</span><br><span class="line">//计算u到v所需时间 </span><br><span class="line">int dis(int u,int v)</span><br><span class="line">&#123;</span><br><span class="line">if(u&gt;v) swap(u,v);</span><br><span class="line">if(u&lt;1||v&gt;k) return 0;</span><br><span class="line">u=a[u];</span><br><span class="line">v=a[v];</span><br><span class="line">    return sum[u]+sum[v]-2*sum[lca(u,v)];</span><br><span class="line">&#125;</span><br><span class="line">signed main()</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%lld%lld&quot;,&amp;n,&amp;k);</span><br><span class="line">int u,v,w;</span><br><span class="line">for(int i=1;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%lld%lld%lld&quot;,&amp;u,&amp;v,&amp;w);</span><br><span class="line">G[u].push_back(&#123;v,w&#125;);</span><br><span class="line">G[v].push_back(&#123;u,w&#125;);</span><br><span class="line">&#125;</span><br><span class="line">dfs(1,0);</span><br><span class="line">father();</span><br><span class="line">for(int i=1;i&lt;=k;i++)</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%lld&quot;,a+i);</span><br><span class="line">s+=dis(i-1,i);</span><br><span class="line">&#125;</span><br><span class="line">for(int i=1;i&lt;=k;i++)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%lld &quot;,s-dis(i-1,i)-dis(i,i+1)+dis(i-1,i+1));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(题解)[AtCoder Beginner Contest 393] D - Swap to Gather</title>
      <link href="/2025/02/19/%5B%E9%A2%98%E8%A7%A3%5D%5BAtCoder%20Beginner%20Contest%20393%5D%20D%20-%20Swap%20to%20Gather/"/>
      <url>/2025/02/19/%5B%E9%A2%98%E8%A7%A3%5D%5BAtCoder%20Beginner%20Contest%20393%5D%20D%20-%20Swap%20to%20Gather/</url>
      
        <content type="html"><![CDATA[<p>原题链接: <a href="https://atcoder.jp/contests/abc393/tasks/abc393_d">原题面</a></p><span id="more"></span><h3 id="问题陈述"><a href="#问题陈述" class="headerlink" title="问题陈述"></a>问题陈述</h3><p>你得到一个长度为 N 的字符串 S ，由 0 和 1 组成。保证 S 至少包含一个 1 。<br>您可以执行以下操作任意次数（可能为零）：<br><strong>· 选择一个整数 i （ 1≤i≤N−1 ）并交换 S 的第 i 个和第 (i+1) 个字符。</strong><br>找出使所有 1 连续所需的最小操作数。<br>这里，所有的 1 被称为是连续的，当且仅当存在整数 l 和 r （ 1≤l≤r≤N ），使得 S 的第 l~r之间都是1</p><h3 id="约定"><a href="#约定" class="headerlink" title="约定"></a>约定</h3><p>2≤N≤5×10^5<br>N 是整数。S 是一个长度为<br>N 的字符串，由 0 和 1 组成。<br>S 至少包含一个 1 。</p><h3 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h3><p>我们来解读一下题意，题目说要把所有的1放在一起，且只能通过交换相邻两个数的方式移动<br>那么我们假设有一个1要从 i 的位置移动到 j ，毫无疑问，移动次数是 j - i (j ≥ i)，也就是<strong>i 和 j 之间的距离</strong><br>此时一切都变得熟悉，距离，最短移动次数，连续，还记得七年级上册学的，求 |x+1|+|x+2| 这个不等式为最小值时，x的值是多少吗？没错，这道题就是它<strong>几何</strong>解法的变种（虽然我在第一次想的时候也没想出来哈哈哈）<br>事实上，这是一个经典的<strong>仓库选址问题</strong>，其最小值的x一定是在中间的(不懂请看：<a href="https://blog.csdn.net/weixin_52797843/article/details/122069259">货仓选址</a>)<br>但唯一有一点不一样的是，求那个不等式时算的是所有点到x这个点的距离，但本题要求的是所有的1都连续，那么怎么表示这个答案呢？<br>我们假设<strong>x的值是中间的那个1的位置</strong>，那么x左边的第一个1(假设位置为k)需要移动的距离就是x-k-1（只需要移动到相邻的那个位置），x左边第二个1(假设位置为q)需要移动的距离就是x-q-2，见图</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/ky1twzs5.png" alt="在这里插入图片描述"><br>我们发现，对于每一个1，它到最终“仓库”的距离是</p><blockquote><p>x-k+<strong>它距离仓库有多少个其他的1</strong></p></blockquote><p>因为每有一个1移动了，下一个1的移动距离就需要<strong>减一个距离单位</strong>(靠在已移动好的那个1旁边)<br>又由于这个字符串只由0或1组成，换句话说，这个字符串要么是0，要么是1<br><strong>如果k到x的距离会因为其中的1而减少，那么统计0的个数就可以了</strong><br>例如，k到x之间有两个0，所以它最少需要移动两步<br>q到x之间有三个0，所以它最少需要移动三步<br>知道了这一点之后，问题就变成了如何确定k与x之间0的个数<br>还是非常简单，类似于初中的线段和差<br>我们记录一下从<strong>0 ~ k中0的个数</strong>，再记录<strong>0 ~ x 中 0 的个数</strong>，两个相减，就得到了<strong>k ~ x中0的个数</strong><br>上代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define ll long long</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">ll n,one[1000001];//&quot;1&quot; 的位置 </span><br><span class="line">ll cnt; //0~k-1中1的个数 </span><br><span class="line">ll x;//仓库的位置 </span><br><span class="line">ll ans;</span><br><span class="line">string a;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;a;</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">if(a[i]==&#x27;1&#x27;) one[cnt+1]=i-cnt,cnt++;</span><br><span class="line">&#125;</span><br><span class="line">x=one[(cnt+1)/2];//仓库选址，取中位数，1一定是优于0的，所以在1的位置中选中位数 </span><br><span class="line">for(int i=1;i&lt;=cnt;i++) ans+=abs(one[i]-x);//算k~x 中0的个数，因为x是中位数，一定存在比它大的1的位置，故需要取绝对值 </span><br><span class="line">cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以为什么我在比赛的时候想不出来。。。</p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kruskal（克鲁斯卡尔）算法原理及图解案例</title>
      <link href="/2025/02/16/kruskal%EF%BC%88%E5%85%8B%E9%B2%81%E6%96%AF%E5%8D%A1%E5%B0%94%EF%BC%89%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%8A%E5%9B%BE%E8%A7%A3%E6%A1%88%E4%BE%8B/"/>
      <url>/2025/02/16/kruskal%EF%BC%88%E5%85%8B%E9%B2%81%E6%96%AF%E5%8D%A1%E5%B0%94%EF%BC%89%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%8A%E5%9B%BE%E8%A7%A3%E6%A1%88%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<p>前置知识：并查集、图的存储<br>参考文献：<a href="https://oi-wiki.org/graph/mst/">OI Wiki</a></p><h3 id="什么是kruskal？"><a href="#什么是kruskal？" class="headerlink" title="什么是kruskal？"></a>什么是kruskal？</h3><p>kruskal是一种最小生成树算法，由Joseph Kruskal在1956年发表<br><strong>最小生成树</strong>（Minimum Spanning Tree，MST）简单来说就是：在一个<strong>连通图</strong>中，找出其中的一个<strong>可以使各个点之间连通</strong>且<strong>路权之和最小</strong>的连接方法，然后根据这个连接方法生成一个树<br>它的实现过程如下：</p><h3 id="算法原理（建议搭配下面的案例一起食用-）"><a href="#算法原理（建议搭配下面的案例一起食用-）" class="headerlink" title="算法原理（建议搭配下面的案例一起食用~~）"></a>算法原理（建议搭配下面的案例一起食用~~）</h3><p>我们将每一个点都看作一个<strong>无根树</strong>（独立的集合），并把这个图上的边全部存储下来，然后<strong>把所有边删掉</strong><br>然后将每一条<strong>边</strong>按权值大小<strong>从小到大</strong>排序</p><p>然后遍历每一条存储下来的边，用<strong>并查集</strong>判断<strong>这条边所连接的两个点是否在同一个集合內（查询是否连通）</strong>，若在，那么就不用添加这条边到最小生成树里去；若不在，这条边<strong>一定</strong>是最小生成树的一部分</p><p>相信没学过的你看到这一句话一定一脸懵，为什么这条边<strong>一定</strong>是最小生成树的一部分呢？</p><p>我们用到了贪心的策略<br>首先，若这两个点连通，那么<strong>先前的连接方案</strong>的权值一定是<strong>小于或等同于</strong>使用这条边连接的，因为假设当前边的权值<strong>小于</strong>先前的连接方案，那么它在排序的时候就到前面去了。故在两个点已经连通的情况下，不能也不需要加入这条边</p><p>若这两个点不连通，那么使用当前边连接这两个点一定是权值最小的，道理很简单，因为边是按照<strong>边是按照权值从大到小排序</strong>的，往后遍历的权值一定大于等于当前边，又因为你要一个最小生成树，所以每两个点之间迟早要连通，所以就赶紧趁着这个最优情况把这两个点连了，故这条边一定是最小生成树的一部分</p><p>以上两种情况可以互相印证，如第一种情况其实就可以看作是<strong>先前连接方案</strong>的第二种情况</p><p>所以当我们把所有边遍历完之后，最小生成树也就出来了</p><h3 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h3><p>首先我们拿到一个图<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/yzvdzj6j.png"></p><p>然后将这个图的每一条边排序得到<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/jsyoryv6.png" alt="在这里插入图片描述"></p><p>我们看第一条边，发现2和5不连通，那么我们就把它连接上<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/q0ift6qb.png?x-oss-process=image/resize,m_lfit,h_170,w_225" alt="在这里插入图片描述"></p><p>然后第二条边，发现3和5也不连通，那么就也把它连接上<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/v6lsybhe.png" alt="在这里插入图片描述"></p><p>然后第三条边，发现1和3也不连通，那么把它连接上<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/gck0n2z4.png" alt="在这里插入图片描述"></p><p>到第四条边的时候，发现1和5是连通的，故跳过<br>第五条边3和4不连通，故连接上<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/uuzw8ink.png" alt="在这里插入图片描述"></p><p>第六条边2和6不连通，故连接上<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/fj46ce7s.png" alt="在这里插入图片描述"></p><p>第七条边1和6连通，故跳过<br>非常简单是不是？（我刚开始的时候也不这么觉得<br>然后我们就得到了一个最小生成树<br>附上一个<strong>输出最小生成树的权值和</strong>的C++代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define ll long long </span><br><span class="line">#define maxn 101</span><br><span class="line">#define maxm 1000001</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">ll n,m,ans;</span><br><span class="line">ll fa[maxn],h[maxn]; //并查集需要用到的两个数组，分别是祖先和家族高度</span><br><span class="line">struct node //使用结构体方便排序与存储</span><br><span class="line">&#123;</span><br><span class="line">ll u,v,w;</span><br><span class="line">&#125;e[maxm];</span><br><span class="line"></span><br><span class="line">ll find(ll r) //找祖宗并更新</span><br><span class="line">&#123;</span><br><span class="line">if(r==fa[r]) return r;</span><br><span class="line">else return fa[r]=find(fa[r]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void merge(ll x,ll y)  //合并集合</span><br><span class="line">&#123;</span><br><span class="line">ll fx=find(x);</span><br><span class="line">ll fy=find(y);</span><br><span class="line">if(h[fx]&gt;h[fy]) fa[fy]=fa[fx];</span><br><span class="line">else if(h[fx]&lt;h[fy]) fa[fx]=fa[fy];</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">fa[fy]=fa[fx];</span><br><span class="line">h[fx]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void kruskal() </span><br><span class="line">&#123;</span><br><span class="line">int cnt=0;//选取边的数量，因为最小生成树的边数一定是n-1（要保证连通），所以可以做一个小剪枝</span><br><span class="line">for(int i=1;i&lt;=n;i++) fa[i]=i; //初始的时候都是独立的集合</span><br><span class="line">for(ll i=1;i&lt;=m&amp;&amp;cnt&lt;=n-1;i++)</span><br><span class="line">&#123;</span><br><span class="line">ll u=e[i].u,v=e[i].v;</span><br><span class="line">ll fu=find(u);</span><br><span class="line">ll fv=find(v);</span><br><span class="line">if(fu==fv) continue ; //若在一个集合，跳过</span><br><span class="line">cnt++; //加入最小生成树</span><br><span class="line">ans+=e[i].w;</span><br><span class="line">merge(u,v); //连接两个点</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool cmp(node a,node b)</span><br><span class="line">&#123;</span><br><span class="line">return a.w&lt;b.w;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">for(ll i=1;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;e[i].u&gt;&gt;e[i].v&gt;&gt;e[i].w;</span><br><span class="line">&#125;</span><br><span class="line">sort(e+1,e+1+m,cmp);</span><br><span class="line">kruskal();</span><br><span class="line">cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有问题欢迎指出呀！~<br>共同进步AwA!</p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2024 CSP 游记</title>
      <link href="/2024/10/27/2024%20CSP%20%E6%B8%B8%E8%AE%B0/"/>
      <url>/2024/10/27/2024%20CSP%20%E6%B8%B8%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>这是我写的第一篇博客,同时也是我OI生涯的开端</p><span id="more"></span><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr><p>暑假开始买了本信奥一本通，结果都没翻开来看，早知道就听 AMC 的不去买书了 www</p><h2 id="初赛"><a href="#初赛" class="headerlink" title="初赛"></a>初赛</h2><hr><p>J 组倒是没啥想说的，当时考完的时候还以为能 AK，结果错了几道判断，遗憾 93.5<br>当时还听说小六的 hwz 98，%%%</p><p>S 组也是给我蒙过去了，完善程序第一题考得刚好是我昨晚复习的二分，一看答案五<br>个 A，觉得肯定错了，但也懒得改，没想到答案还真是这样，最后 57.5 拿下</p><h2 id="复赛"><a href="#复赛" class="headerlink" title="复赛"></a>复赛</h2><hr><p>day 0 考前一天被班上同学全票选上班长（www…我要辞职）<br>结果晚上班级搞大扫除，六点开始的赛前集训我七点才到 后来也就是和其他 Oler 和 教练聊了会天，感觉状态非常好<br>后来就出发去考场旁边的酒店住了一晚（没睡好）</p><h2 id="day1-J"><a href="#day1-J" class="headerlink" title="day1-J"></a>day1-J</h2><hr><p>早上 7：00 起来昏沉沉的，当时就想这次肯定完蛋了，开考前也没太紧张(估计是没睡好所以才不觉得紧张)<br>然后就和其他 Oler 一起去考场等了</p><p>8：30 准时开考，由于是第一次考，一开始忘记了考试题是放在 D 盘里的，还纳闷怎么没有考<br>试文件，结果旁边的女选手也没意识到，还是个 i 人，愣是考了半小时她才说，好在我天资聪慧，想了 2 分钟终于想起来了</p><h3 id="看题"><a href="#看题" class="headerlink" title="看题"></a>看题</h3><hr><p>把四道题扫了一眼，初步判定前 A 题是水题，B 题搜索， C 题动规，D 题应该是个图</p><p>T1 poker</p><p>桶去重秒了，10mins 切了第一题，考完才想起来可以用 set</p><p>T2 explore</p><p>仔细看了题才发现这和搜索没关系，纯纯一送分模拟，20mins 切了</p><p>T3 sticks</p><p>题目让用 n 个火柴棒搭一个最小的数字，然后把每数字需要的火柴棒都给了你<br>读题的时候就觉得这几个特殊性质有意思，但还是没多想，在脑海中抽象了 10 几分钟，啥也没想到<br>没办法，先写了个深搜，突然发现 long long 放不下，直接改了 string（。。。）<br>再后来发现白改了，改了也 TLE，白费 10mins，再后来绞劲脑汁想优化没结果啥都没想到，无奈打表，把 n&lt;&#x3D;50 的情况全部打出来，发现答案好多 8，才意识到这就是个数学题，结合特殊性质的提示，<br>得出结论： 为了让数字最小，就得让数字位数最小，选择火柴棒根数最多的 8 来搭就能达到这一目的，然后就是相同余 数下的开头两位数不同，其他都是 8，最后为了保险，把 20 以内的数据都放在了数组里，这样就避免了特判， 考完就发现好多人没有注意到 n&#x3D;17 要特判，嘿嘿 写完这题的时候我那叫一个慌张，觉得这个答案未免太离谱，一堆 8，好在我心里素质强，坚信这是正解，花了 2 小时才切掉这题</p><p>T4 chain</p><p>看完 D 题果断放弃，这不是我可以写出来的（看题都看了半天，一开始看题都看错了，直接怀疑起样例解释）， 甚至爆搜都没有思路，回去检查罚坐了一小时</p><h3 id="最后估计：100-100-100-0-300"><a href="#最后估计：100-100-100-0-300" class="headerlink" title="最后估计：100+100+100+0&#x3D;300"></a>最后估计：100+100+100+0&#x3D;300</h3><hr><p>问了一下大家感觉 300 也就是个大众分，不过第一次考我已经很满意了，争取明年 AK！</p><h2 id="day1-S"><a href="#day1-S" class="headerlink" title="day1-S"></a>day1-S</h2><hr><h3 id="考前"><a href="#考前" class="headerlink" title="考前"></a>考前</h3><p>考完 J 组吃完午饭都接近两点了，午觉是一点没睡成，加上晚上没睡好，我还开玩笑和同学说去 S 赛场睡两小时</p><h2 id="看题-1"><a href="#看题-1" class="headerlink" title="看题"></a>看题</h2><hr><p>扫了一眼，觉得 A 题是个背包，B 题模拟+高中物理（加速度），C 题动规，D 题不想看，一看就写不出来（考完 去洛谷看了眼，黑题，好险没浪费时间）<br>T1 duel</p><p>一开始以为是个 01 背包，抽象了一下发现不是，数据范围不大，我直接桶排，然后根据当前项比较上一项，由于此时 每只怪兽数值都是有序的，所以只有两种情况： 1、当前项数量小于上一项，那就直接把上一项替换成当前项，最小剩下总数目不变 2、当前项数量大于上一项，那就直接把剩余数量加上数量之差 20mins 切掉第一题</p><p>T2 detect</p><p>一开始想着 AC 他，花 20mins 写了个 O(nm)的代码，发现读入的数据不对，排了半天错误，结果发现是把 int 数组开成了 bool，在上面花了 60mins，我直接红温，转到 T3<br>过了一会发现 T3 也写不出来，想着回来偷点分<br>然后就看特殊性质，发现 B 和 C 的性质很好拿分 B 和 C 的特殊性质只需要在最后一个检查站判断是否超速就行了，如果没有车辆超速，那就可以把所有检查站撤除，否则就保留最后一个，用时 45mins<br>当时加速度为负数的时候想半天想不到解法，考完试一听见有人说二分就悟了，哎，事后诸葛亮</p><p>T3 color</p><p>看了题，果断选择用二进制表示颜色，暴力搜索，然后过了小样例，后来脑抽换了深搜想优化，结果啥都没优化出来，果断 放弃，用时 20mins</p><h3 id="最后估计：100-40-20-160"><a href="#最后估计：100-40-20-160" class="headerlink" title="最后估计：100+40+20&#x3D;160"></a>最后估计：100+40+20&#x3D;160</h3><hr><p>一起学的Oler好像也就是写出来了第一题多一点点，平均水平吧只能说，但是我已经算发挥的很好了 第一次参加 csp，对于这个成绩我已经很满意了，前途无限呀！</p>]]></content>
      
      
      <categories>
          
          <category> 闲谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游记 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
